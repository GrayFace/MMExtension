local abs, floor, ceil, round, max, min = math.abs, math.floor, math.ceil, math.round, math.max, math.min
local i4, i2, i1, u4, u2, u1 = mem.i4, mem.i2, mem.i1, mem.u4, mem.u2, mem.u1
local mmver = offsets.MMVersion

local function mmv(...)
	local ret = select(mmver - 5, ...)
	assert(ret ~= nil)
	return ret
end

local OldCount, NewCount = mmv(558, 526, 526), nil

local function Process(t, d)
	for _, p in ipairs(t) do
		u4[p] = u4[p] + d
	end
end

local function Extend(p, size, t, tend, extraSize)
	local esize = tonumber(extraSize) or 0
	local new = mem.StaticAlloc(size*NewCount + esize)
	mem.copy(new, p, size*min(OldCount, NewCount) + esize)
	if extraSize == 'fill' then
		for i = OldCount, NewCount - 1 do
			mem.copy(new + i*size, p, size)
		end
	end
	Process(t, new - p)
	if tend then
		Process(tend, new - p + (NewCount - OldCount)*size)
	end
	return new
end

local function ChangeGameArray(name, p, count)
	structs.o.GameStructure[name] = p
	internal.SetArrayUpval(Game[name], "o", p)
	internal.SetArrayUpval(Game[name], "count", count or NewCount)
end

mem.autohook(mmv(0x43918F, 0x443862, 0x440681), function(d)
	NewCount = DataTables.ComputeRowCountInPChar(d.eax, 6, 6) - 1
	if NewCount <= OldCount then
		return
	end
	
	-- extend the array
	local ptr, door

	mem.IgnoreProtection(true)
	if mmver == 6 then
		ptr = Extend(0x52D530, 0x30,
			{0x419C14, 0x42F094, 0x4391A4, 0x439FDC, 0x43A067, 0x43A11C, 0x43A122, 0x43C163, 0x43C16A, 0x43C180, 0x43C2A3, 0x43C41E, 0x43C42C, 0x43C571, 0x43C5AB, 0x4851A6, 0x4851AC, 0x48A1CF, 0x48A1D5, 0x48A262, 0x48A268, 0x48A312, 0x48A322, 0x496354, 0x496446, 0x4964A8, 0x496529, 0x497F09, 0x497FA0, 0x497FA6, 0x498338, 0x499E46, 0x499F30, 0x499F96, 0x49A0C0, 0x49A16D, 0x49B850, 0x49BAE6, 0x49C4D0, 0x49C4F0, 0x49C6DA, 0x49C727, 0x49CECB, 0x49CEE8, 0x49D7BA, 0x49D8EB, 0x49DD71, 0x49DDAA, 0x49DF92, 0x49E125, 0x49E5E3, 0x49E75F, 0x49ECFC, 0x49EEF5, 0x49F345, 0x49F40D, 0x49F49B, 0x49F67F, 0x49F7E1, 0x49F885, 0x49F8E0, 0x49F8FC, 0x49F950, 0x49FB59, 0x49FD18, 0x49FD59, 0x49FF18, 0x4A434D, 0x4A438D, 0x4A466E, 0x4A476D, 0x4A47BF, 0x4A4825, 0x4A484F, 0x4A48B7, 0x4A4911, 0x4A4963, 0x4A49C9, 0x4A49F3, 0x4A4A57, 0x4A4D19, 0x4A4E83, 0x4A4F3B, 0x4A5029, 0x4A50C1, 0x4A51E2, 0x4A527A, 0x4A530E, 0x4A5409, 0x4A5481, 0x4A5553, 0x4A5637, 0x4A5700},
			{0x4395EB}
		)
	elseif mmver == 7 then
		ptr = Extend(0x5912B8, 0x34,
			{0x40D627, 0x41CC46, 0x433349, 0x443872, 0x4447C3, 0x4449A4, 0x444A1D, 0x44609F, 0x4460BC, 0x4460D6, 0x44622E, 0x4462D8, 0x4462DF, 0x446401, 0x446431, 0x490FAF, 0x4957D5, 0x4957E9, 0x495893, 0x4959B7, 0x4B1DFB, 0x4B318A, 0x4B31C3, 0x4B3287, 0x4B328D, 0x4B3542, 0x4B4748, 0x4B47CF, 0x4B54A2, 0x4B5D4A, 0x4B6443, 0x4B645D, 0x4B691A, 0x4B6931, 0x4B7032, 0x4B7090, 0x4B7331, 0x4B8259, 0x4B834D, 0x4B85B4, 0x4B8602, 0x4B87B9, 0x4B8DB4, 0x4B8ED4, 0x4B8F11, 0x4B904E, 0x4B95CE, 0x4B9CE8, 0x4BADED, 0x4BC85F, 0x4BC8EB, 0x4BD317, 0x4BD442, 0x4BD566, 0x4BD5B5, 0x4BD61A, 0x4BD63F, 0x4BD697, 0x4BD706, 0x4BD72B, 0x4BD783, 0x4BDA1A, 0x4BDBBC, 0x4BDCDD, 0x4BDEB5, 0x4BE00E, 0x4BE179, 0x4BE25F},
			{0x443C9B}
		)
	else
		ptr = Extend(0x5A5728, 0x34,
			{0x40E819, 0x41C167, 0x430BE6, 0x440693, 0x44169E, 0x44174C, 0x441A36, 0x442EA1, 0x442EB6, 0x442ED1, 0x443004, 0x4430D2, 0x4430D9, 0x443224, 0x445567, 0x4900D3, 0x493AA0, 0x493AB1, 0x493B5D, 0x493C64, 0x4B0665, 0x4B1AB3, 0x4B1AEC, 0x4B1BAE, 0x4B1BB9, 0x4B1E5E, 0x4B317A, 0x4B32A0, 0x4B3F12, 0x4B4764, 0x4B4B5E, 0x4B5146, 0x4B515F, 0x4B5445, 0x4B545C, 0x4B5863, 0x4B58BC, 0x4B5B32, 0x4B6844, 0x4B68F9, 0x4B6B46, 0x4B6B94, 0x4B6D30, 0x4B7308, 0x4B7492, 0x4B74CF, 0x4B760D, 0x4B7B9C, 0x4B8260, 0x4B9330, 0x4BA912, 0x4BAF49, 0x4BB016, 0x4BB05E, 0x4BB0CB, 0x4BB0EF, 0x4BB146, 0x4BB1B9, 0x4BB1DD, 0x4BB234, 0x4BB2C7, 0x4BB618, 0x4BB7C3, 0x4BB8E5, 0x4BBAF7, 0x4BBC43, 0x4BBCCE, 0x4BBD85},
			{0x440A9E}
		)
	end
	mem.IgnoreProtection(false)
	
	ChangeGameArray("Houses", ptr)
end)
